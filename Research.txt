Repository: https://github.com/msrsaditya/Local-Transfer

get.sh (Linux):

#!/usr/bin/env bash
set -euo pipefail

folder="${1:-${HOME}}"
port=64943

mkdir -p "${folder}"

nc -l -w 60 "${port}" | {
  IFS= read -r file
  if [[ -z "${file}" ]]; then
    tar --no-same-owner --warning=no-unknown-keyword -xpf - -C "${folder}"
  else
    cat > "${folder}/${file}"
  fi
}

send.sh (Linux):

#!/usr/bin/env bash
set -euo pipefail

path="${1}"
ip="${2}"
port=64943
flags=(-f -b -t -r -a -p -i 0.5 -e --si)

if [[ ! -e "${path}" ]]; then
  echo "Error: Path Not Found => ${path}" >&2
  exit 1
fi

if ! [[ "${ip}" =~ ^[0-9.]+$ ]]; then
  echo "Error: Invalid IP format => ${ip}" >&2
  exit 1
fi

lastpart=$(basename "${path}")

if [[ -d "${path}" ]]; then
  size=$(du -sb "${path}")
  bytes=${size%%[[:space:]]*}

  parentdir=$(dirname "${path}")
  stream() {
    printf "\n"
    tar --exclude='._*' --exclude='.DS_Store' -cpf - -C "${parentdir}" "${lastpart}"
  }
else
  bytes=$(stat -c%s "${path}")
  
  stream() {
    printf "%s\n" "${lastpart}"
    cat "${path}"
  }
fi

stream | pv "${flags[@]}" -s "${bytes}" | nc -N "${ip}" "${port}"

get.sh (macOS):

#!/usr/bin/env bash
set -euo pipefail

folder="${1:-${HOME}}"
port=64943

mkdir -p "${folder}"

nc -l -w 60 "${port}" | {
  IFS= read -r file
  if [[ -z "${file}" ]]; then
    tar --no-same-owner -xpf - -C "${folder}"
  else
    cat > "${folder}/${file}"
  fi
}

send.sh (macOS):

#!/usr/bin/env bash
set -euo pipefail

export COPYFILE_DISABLE=1

path="${1}"
ip="${2}"
port=64943
flags=(-f -b -t -r -a -p -i 0.5 -e --si)

if [[ ! -e "${path}" ]]; then
  echo "Error: Path Not Found => ${path}" >&2
  exit 1
fi

if ! [[ "${ip}" =~ ^[0-9.]+$ ]]; then
  echo "Error: Invalid IP format => ${ip}" >&2
  exit 1
fi

lastpart=$(basename "${path}")

if [[ -d "${path}" ]]; then
  size=$(du -sk "${path}")
  bytes=${size%%[[:space:]]*}
  bytes=$((bytes * 1024))

  parentdir=$(dirname "${path}")
  stream() {
    printf "\n"
    tar --exclude='._*' --exclude='.DS_Store' -cpf - -C "${parentdir}" "${lastpart}"
  }

else
  bytes=$(stat -f%z "${path}")
  
  stream() {
    printf "%s\n" "${lastpart}"
    cat "${path}"
  }
fi

stream | pv "${flags[@]}" -s "${bytes}" | nc "${ip}" "${port}"

Program.c

#include<sys/socket.h>
#include<netinet/in.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<unistd.h>
#include<sys/mman.h>
#include<arpa/inet.h>
#define P 8192
int main(int c,char**v){
    int s,f,l,n,x,y,z;
    struct sockaddr_in a;
    char*m,b[P];
    struct stat t;
    a.sin_family = AF_INET;
    a.sin_port = htons(1337);
    a.sin_addr.s_addr = INADDR_ANY;
    s=socket(AF_INET,SOCK_STREAM,0);
    if(c>2&*v[1]=='s'){
        bind(s,(struct sockaddr*)&a,sizeof(a));
        listen(s,1);
        x=accept(s,0,0);
        f=open(v[2],O_RDONLY);
        fstat(f,&t);
        l=t.st_size;
        send(x,&l,4,0);
        m=mmap(0,l,PROT_READ,MAP_SHARED,f,0);
        for(y=0;y<l;y+=z)z=send(x,m+y,l-y>P?P:l-y,0);
        close(f);close(x);
    }else if(c>2){
        a.sin_addr.s_addr=inet_addr(v[1]);
        connect(s,(struct sockaddr*)&a,sizeof(a));
        recv(s,&l,4,0);
        f=open(v[2],O_CREAT|O_WRONLY|O_TRUNC,0644);
        for(y=0;y<l;){
            z=recv(s,b,P>l-y?l-y:P,0);
            write(f,b,z);
            y+=z;
        }
        close(f);
    }
    close(s);
}

README.md of above repository:

# Local-Transfer
- The simplest way to transfer files over a trusted local network.
- Simple as in "software", not as in "user experience"
- This is the lowest high-level (or highest low-level) way to achieve this.

## Installation
- pv is the only dependency
- Make sure to install the latest version (pv 1.9.31)
- macOS's Homebrew and Termux's pkg both provide this latest version but if you're on Debian/Ubuntu/Linux Mint, you will get an older version, in which case you need to build from the source
- [OR] you can omit the --si flag from pv in send.sh
- The script works even without pv, you can just omit related code but you won't get a progress bar though.

## Usage

### Receiver
```bash
bash get.sh "/path/to/folder"
```
```bash
bash get.sh "~/storage/shared/Download/"
```

### Sender
```bash
bash send.sh "/path/to/file[OR]folder/" <IP_ADDRESS>
```
```bash
bash send.sh "~/Documents/file.pdf" 192.168.29.14
```

# Tradeoffs
- Many features have been intentionally removed to reduce the overhead of the file transfer as much as possible.
- Removed/Avoided features:

1. Authentication & Authorization
2. Encryption
3. Pause/Resume
4. Partial file handling
5. Temp file creation
6. Compression
7. Checksum verification
8. Extensive error handling
9. Config files
10. Logging

And many many more.

- Only use this if you are ready to accept these tradeoffs.

# Benchmarks
- Under extremely good conditions (everything is perfect) we can get >103 MBps with these scripts on a gigabit network.
- This is >95% of average iPerf3 speeds (106-108 MBps) on the same device under the same conditions.
- This is >90% of modern ethernet speeds (110-115 MBps).
- This is >82% of the theoretical maximum speeds (125 MBps) of the gigabit network itself.
- The 5% overhead compared to iPerf3 is the unavoidable overhead from TCP and other tools, such as tar, pv, and bash.
- Note that these metrics are achievable under extremely good conditions, these benchmarks show us what is possible, not what happens usually. If the sender and receiver are far away, have poor radios, and there's a lot of noise and disturbance in the network, with lots of packet drops and so on... then we will observe much slower speeds.

- The code is very lean; 44 lines of shell code.

# Micro-optimizations
- The goal is not just to build a highly optimized solution, it's to build the simplest possible highly optimized solution.
- What is the simplest solution one can create that can maximize speed/performance/throughput/latency as much as possible? This is what we're aiming for.
- We can always add a niche platform-specific CPU optimization that's going to save us 0.0000002 ms in latency but drastically reduce the readability, maintainability, and simplicity of our scripts.
- For context, if we transfer a 100 GB file (a file so big that most people won't transfer usually), then it would take 
16.57 minutes with 103 MBps (our script - under extremely good conditions ONLY) compared to 13.65 minutes with 125 MBps (theoretical limit).
- This means we'll roughly save around ~3 minutes at max on a very massive file occasionally at best. Note that this much savings can never be achieved, because 125 MBps is impossible practically. It is the max that we can achieve, that's all (Not worth it IMHO).
- But this doesn't mean we shouldn't optimize. The 103 MBps is under ideal conditions only, maybe those optimizations can help us achieve 103 MBps in non-ideal conditions too. That's a clear win.

- However, if you still want to do all of these micro-optimizations though, there's a Program.c file in the repo.
- Compile it with
```bash
clang Program.c
```
- And run
```
./a.out s /path/to/file
```
```
./a.out 192.168.29.194 /filename/to/saveas
```
- The extreme optimization approach results in unreliable transfers most of the time. Also, there's no progress bar or timeout, so watch out :)
- It works when it works, but when it does, it results in extremely fast speeds.

- I usually do file transfers among devices in my trusted local network.
- Device's OS type: macOS, Linux and Termux
- File/Folder type: Videos (mostly) and text files
- Connection type: Both are connected to Wi-Fi or mobile hotspot wirelessly
- File size: Very large, at least 10 GB+
- This is usually done in my home, so consider typical consumer conditions everywhere.

Given all of these, can these file transfer bash scripts still be made any more faster? Is there a proven method to consistently improve key metrics, such as performance, throughput, and latency, across various systems?

Here are the guidelines for suggesting changes:

Any changes or potential improvements you suggest:

- Should refer to the software side, not the hardware side (for any hardware - these scripts (software) should provide speeds that are as good as anything could get with that hardware ever.
- Any changes or potential improvements shouldn't worsen the existing speeds (diminishing returns) and should consistently give us at least 5%-10%+ improvements, or should at least be dead simple to implement.

- If it's not giving us consistent improvements or is not simple to implement, then it's not worth the tradeoff of simplicity of code for marginal/niche improvements/optimizations.
- Anything you claim is a "speedup" must be benchmarked. In general, the goal is simplicity, so even if your change makes things marginally faster, you have to consider the tradeoff with maintainability and readability.
- Niche micro optimizations with diminishing returns are highly discouraged.
- Any changes or potential improvements should be cross-platform (should work well, as intended, on all platforms (macOS, Linux, and Termux)); it should not be the case that a clear improvement in one platform is a clear degradation in the other.
- But, if a syntax creates cross-platform compatibility issues, but can still improve the speed/performance on all platforms, we can use a different syntax. The scripts I provided are for Linux only. I have a separate pair of scripts for macOS, so syntax compatibility is not a concern. However, platform compatibility for that behavior is not.
- No code golf! While a low line count is a guiding principle of this project, any code golf-like approach will be disregarded. The true goal is to reduce complexity and increase readability, and deleting \ns does nothing to help with that.
- Refactors that are clear wins. In general, if your refactor isn't a clear win, it will be ignored. But some refactors are amazing! Consider readability in a fundamental sense. A whitespace change or moving a few functions around is useless, but if you realize that two 100-line tasks can use the same 110-line function with arguments while also improving readability, this is a big win.
- Dead code removal is also highly encouraged. But again, no code golf!
- Provide suggestions about improving speed, performance, throughput, latency, and so on... No need for anything else like better error handling, improving robustness, or reliability, and so on... (I will handle those aspects, you're only concern is about metrics like speed, performance, throughput, latency, and so on...)
- Be comprehensive in your analysis before providing any suggestions. Consider everything carefully, taking your own time. Quality is always way more important than quantity.
- Whenever in doubt, feel free to search online. I need absolute perfection.

I'll also tell you what we can't (need not) optimize:

Of all the tools we're using in our script,

basename
dirname
cat
mkdir
du

are all strictly POSIX-compliant, so no need to replace these with a better tool (these are already highly optimized)

tar
stat

are not POSIX-compliant but are available by default (pre-installed) on almost all UNIX-like or UNIX-based machines, so any replacement you offer should at least be one that's pre-installed like above

nc (netcat) is pre-installed on macOS and some Linux distributions (not all), so any replacement you offer should at least be one that's pre-installed like above

pv needs to be installed as a dependency, so any replacement you offer should at least be better (simpler, faster, more efficient) than pv

Research extensively, thoroughly and extremely carefully about this, I need an extremely certain, well-researched, ultimate final verdict about this.

Don't suggest using mbuffer because here's what I found out about availability of mbuffer in an article on the Internet:

"## Historical Context

There was actually a request to add mbuffer to Homebrew back in 2014, and there was even a pull request (#31018) that added mbuffer v20130220 to the legacy Homebrew repository, which used a Mac port from the ZFS-OSX project.

## Technical Issues

The main reason mbuffer isn't available in current Homebrew is due to **fundamental macOS compatibility issues**:

1. **Missing POSIX semaphore support**: mbuffer relies on the `sem_getvalue()` function, which is part of the POSIX semaphore API. However, macOS deliberately doesn't implement this function, making it incompatible with the standard mbuffer codebase.

2. **Maintenance burden**: The original mbuffer code requires significant patches to work on macOS, as evidenced by the need for special ports like the "mbuffer-osx" project. These patches need to be maintained separately from the upstream project.

3. **Limited demand**: Unlike Linux systems where mbuffer is commonly used, macOS users have fewer use cases for it, making it a lower priority for Homebrew maintainers.

## Current Status

- **Legacy Homebrew**: mbuffer was available in the old legacy Homebrew repository but was not carried forward to the current Homebrew/homebrew-core
- **No upstream macOS support**: The original mbuffer project doesn't officially support macOS
- **Alternative solutions**: macOS users typically use other tools like `pv` (pipe viewer) for similar functionality, which is readily available in Homebrew

## Why Not Re-added

Homebrew generally avoids including packages that:
- Require significant platform-specific patches
- Have upstream compatibility issues
- Have limited user demand on the platform
- Have suitable alternatives already available

This is why mbuffer remains available through MacPorts (which specializes in porting Unix software to macOS) but not through Homebrew (which prefers packages that work well natively or with minimal modifications)."

pv -B 256M
tar no blocking
and others

buffer optimizations
